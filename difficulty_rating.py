# 1. Алгоритм проверки наличия дубликатов в массиве.

def has_duplicates(arr):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] == arr[j]:
                return True
    return False


'''
Временная сложность функции - O(n^2): и внешний, и вложенный цикл имеет сложность O(n),
так как необходимо пройтись по всем элементам списка (в худшем случае).
В лучшем случае самая первая пара уже будет дубликатом, но в худшем случае дубликатами окажутся последние значения.
Также внутри имеется сравнение if, временная сложность которого O(1), так как это простое сравнение по индексам.
'''

# 2. Алгоритм поиска максимального элемента в неотсортированном массиве.

def find_max(arr):
    max_val = arr[0]
    for val in arr:
        if val > max_val:
            max_val = val
    return max_val


'''
Временная сложность функции - O(n), так как цикл пройдётся по всем элементам массива, это обычный линейный поиск.
Также внутри имеется сравнение if и присваивание значения, временная сложность которых O(1).
В худшем случае каждый последующий элемент будет больше предыдущего и каждый раз будет срабатывать присваивание,
в лучшем - самый большой элемент - первый.
'''

# 3. Алгоритм сортировки выбором (Selection Sort).

def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

'''
Временная сложность функции - O(n^2): и внешний, и вложенный цикл имеет сложность O(n),
так как необходимо пройтись по всем элементам списка.
В данном алгоритме в любом случае необходимо пройти через весь массив.
Также внутри имеется сравнение if, присваивание значения и обмен элементов местами, временная сложность которых O(1).
'''

# 4. Алгоритм быстрой сортировки (Quick Sort).

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)


'''
В лучшем и среднем случае временная сложность - O(n log n),
так как массив может быть разделён на равные, или близко к этому, части..
В худшем случае - O(n^2), так как в середине массива (выбранный элемент pivot) может оказаться самый маленький/самый большой элемент.
'''

# 5. Алгоритм вычисления n-го числа Фибоначчи (рекурсивно).

def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)


'''
Временная сложность - О(2^n).
При вызове функции, она вызывает себя дважды, и при одной рекурсии вычисляет одно и то же значение два раза.
Например, при вызове функции от числа 5, она вызовется от чисел 4 и 3, при вызове от числа 4, вызовется от чисел 3 и 2.

При увеличении единицы входных данных на один, количество итераций алгоритма увеличивается в два раза.
Для больших значений неэффективна.
'''

